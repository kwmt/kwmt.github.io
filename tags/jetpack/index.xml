<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jetpack on Androg</title>
    <link>https://kwmt27.net/tags/jetpack/</link>
    <description>Recent content in Jetpack on Androg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 12 Jun 2021 21:25:00 +0900</lastBuildDate>
    
	<atom:link href="https://kwmt27.net/tags/jetpack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Jetpack ComposeでCameraXを実装する</title>
      <link>https://kwmt27.net/2021/06/12/jetpack-compose-camerax/</link>
      <pubDate>Sat, 12 Jun 2021 21:25:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/06/12/jetpack-compose-camerax/</guid>
      <description>はじめに composeバージョンは下記です。
   Jetpack ComposeでのCameraXの実装を試したのでメモしておきたいと思います。 下の動画のようなイメージです。
ソースはGitHubにおいてます。 https://github.com/kwmt/JetpackComposePlayGround/tree/main/camerax/src/main/java/net/kwmt27/camerax
実行するときはConfigurationをcameraxを選択してから実行してみてください。
CameraXはAndroidViewを使う 現在のところ、CameraXを使うにはAndroidViewを使うしかなさそうです。 以下のようにしました。
   usecaseをバインドする usecaseをバインドしてるところは下記のところです。 使用しているUseCaseは、Preview、ImageAnalysisです。 この部分はいままでのcomposeを使わない場合と同じですね。
   RuntimePermissionの実装 カメラはもちろんRuntimePermissionの実装が必要でそれは次のようにやっています。
まず、カメラパーミッションが拒否されたときの画面を作成します。
   このとき、設定画面にstartActivityResultで行って、戻ってきたときのイベントを伝えるために callback: () -&amp;gt; Unitを渡していますので、設定画面から戻ってきたら handler.requestがよばれます。
   handlerはPermissionHandlerという自前のクラスを作っていて、そこでカメラパーミッションが許可されてなければ、設定画面に遷移するし、許可されていれば、onGrantedというFlowに通知します。
   以上です。</description>
    </item>
    
    <item>
      <title>Jetpack Composeでインクリメンタルサーチ(SearchBar UI)を実装するには</title>
      <link>https://kwmt27.net/2021/05/15/jetpack-compose-searchbar/</link>
      <pubDate>Sat, 15 May 2021 13:20:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/05/15/jetpack-compose-searchbar/</guid>
      <description>はじめに composeバージョンは 1.0.0-beta04 です。
検索入力欄に検索した文字列を入れるとリストが絞り込まれる、いわゆるインクリメンタルサーチを実装したいとおもいます。下の動画のようなイメージです。
SearchBarのUIを作るには？  だいたいこんな感じで作れます。
ROOMで部分検索するには @Dao interface QrResultDao { @Query(&amp;quot;SELECT * from qr_results WHERE text LIKE &#39;%&#39; || :query || &#39;%&#39; &amp;quot; + &amp;quot;OR name LIKE &#39;%&#39; || :query || &#39;%&#39; ORDER BY updated_at DESC&amp;quot;) suspend fun search(query: String): List&amp;lt;QrResultEntity&amp;gt; }  こんな感じ。
ViewModelの実装は  SearchQrResultUseCaseを使ってますが、基本的にはDaoのsearchまでの橋渡しなので省略。型変換とかはしています。
SearchBarとリストをくっつけると  listを監視して、検索されたらUIに通知するみたいな感じです。
以上です。</description>
    </item>
    
    <item>
      <title>Jetpack Compose PlayGround</title>
      <link>https://kwmt27.net/2021/03/28/jetpack-compose-playground/</link>
      <pubDate>Sun, 28 Mar 2021 19:00:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/03/28/jetpack-compose-playground/</guid>
      <description>はじめに ※こちらは更新予定です。
確認環境は下記です。
 compose_version: 1.0.0-beta02 kotlin version: 1.4.31 Android Studio version: Android Studio Arctic Fox | 2020.3.1 Canary 12  確認したコードはGitHubにおいてます。
https://github.com/kwmt/JetpackComposePlayGround
縦方向（Vertical）のリスト表示するには 縦方向（Vertical）のリストを表示するには、LazyColumn を使います。
import androidx.compose.foundation.lazy.LazyColumn @Composable fun SampleList() { LazyColumn { items(5) { index -&amp;gt; // 各要素で表示したいUIを書く。 ListItem(index) } } }  多くのアイテムやサイズのわからないリストを表示する必要がある場合、Columnのようなレイアウトを使用すると、全てのアイテムが表示されるかどうかに関わらずレイアウトされるので、パフォーマンスに影響があります。 LazyColumnやLazyRowは表示されるアイテムのみをレイアウトするコンポーネントになります。（RecyclerViewと同じ概念）
ついでに、リストの各要素はComposableListItemは自作のComposable関数で、リストアイテムのUIを定義しています。
@Composable fun ListItem(index: Int = 0) { Column { Box( modifier = Modifier .height(200.dp) .background(Color.Blue) .fillMaxWidth() ) { Text( modifier = Modifier.</description>
    </item>
    
    <item>
      <title>Jetpack Compose Dev Challenge Week3で学んだことまとめ</title>
      <link>https://kwmt27.net/2021/03/15/jetpack-compose-dev-challenge-week3/</link>
      <pubDate>Mon, 15 Mar 2021 12:00:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/03/15/jetpack-compose-dev-challenge-week3/</guid>
      <description>jetpack compose
全体にかかわること(テーマなど) 背景を入れるには Surface(color = MaterialTheme.colors.primary)  が大事
Welcome画面 Login画面 Textの途中でリンクを入れる https://stackoverflow.com/questions/65567412/jetpack-compose-text-hyperlink-some-section-of-the-text
EditTextの枠線の色を変更するには outlinedTextFieldColorsの部分
OutlinedTextField( modifier = Modifier .height(56.dp) .fillMaxWidth(), value = &amp;quot;&amp;quot;, onValueChange = { /*TODO*/ }, placeholder = { Text( text = &amp;quot;Password (8+ characters)&amp;quot;, style = DevChallengeTheme.typography.body1, color = DevChallengeTheme.colors.textBody1, ) }, colors = outlinedTextFieldColors( cursorColor = DevChallengeTheme.colors.textBody1, focusedBorderColor = DevChallengeTheme.colors.textBody1.copy(alpha = ContentAlpha.high), unfocusedBorderColor = DevChallengeTheme.colors.textBody1, ), singleLine = true, )  検索ボックスを作成（SearchBar) ここが参考になりそう。 https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/ui/home/search/Search.kt</description>
    </item>
    
    <item>
      <title>Animation and Jetpack Compose</title>
      <link>https://kwmt27.net/2021/03/06/jetpack-compose-animation/</link>
      <pubDate>Sat, 06 Mar 2021 12:30:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/03/06/jetpack-compose-animation/</guid>
      <description>はじめに Jetpack Compose: Animation
単一アニメーション @Composable fun AnimateAsStateDemo() { var blue by remember { mutableStateOf(true) } val color = if (blue) Blue else Orange Column { Button(onClick = { blue = !blue }) { Text(text = &amp;quot;CHANGE COLOR&amp;quot;) } Spacer(modifier = Modifier.height(16.dp)) Box( modifier = Modifier .size(128.dp) .background(color) ) } }  この例では、BooleanのStateの値blueを持っていて、 ボタンをクリックするとそのStateは反転します。
BoxのカラーがそのBooleanの状態によって切り替わります。
カラーの変更部分をanimateColorAsSate関数でラップすることで、簡単にアニメーションすることができます。（デフォルトはフェードアニメーションなのかな？）
val color by animateColorAsState(if (blue) Blue else Orange)  （初回だけアニメーションしてないように見える）
複数のアニメーションを同時に実行したい 以下はBoxのサイズとカラーの値を同時に変更しています。まだアニメーションはしていません。
private enum class BoxState { Small, Large } @Composable fun UpdateTransitionDemo() { var boxState by remember { mutableStateOf(BoxState.</description>
    </item>
    
    <item>
      <title>State and Jetpack Compose</title>
      <link>https://kwmt27.net/2021/03/06/jetpack-compose-state/</link>
      <pubDate>Sat, 06 Mar 2021 12:30:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/03/06/jetpack-compose-state/</guid>
      <description>はじめに 基本的には、書きを参考に自分なりにまとめたものです。
 State and Jetpack Compose Jetpack Compose 入門 composeバージョンは 1.0.0-beta01 です。  State Composeでは状態をStateというもので扱います。
外から変更可能な MutableStateと外からは変更できないStateがあります。
@Stable interface MutableState&amp;lt;T&amp;gt; : State&amp;lt;T&amp;gt; { override var value: T operator fun component1(): T operator fun component2(): (T) -&amp;gt; Unit }  @Stable interface State&amp;lt;T&amp;gt; { val value: T }  var expanded by remember { mutableStateOf(false) }  mutableStateOfで新しいBooleanのStateを作成しています。
Buttonのクリックイベントの中でその値を変更しています。
onClick = { expanded = true }  Stateを使っている箇所が再描画されます。
Composable関数は必要に応じて再実行されます。これをrecomposition(再構成) とよびます。</description>
    </item>
    
    <item>
      <title>Layout in Jetpack compose</title>
      <link>https://kwmt27.net/2021/02/07/jetpack-compose-layout/</link>
      <pubDate>Sun, 07 Feb 2021 14:30:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/02/07/jetpack-compose-layout/</guid>
      <description>はじめに 基本的には、こちらのコードラボをメモしたものです。 https://developer.android.com/codelabs/jetpack-compose-layouts
試したことはこちらに置いてます。
縦に並べるには Column を使う
Column { Text(&amp;quot;Alfred Sisley&amp;quot;, fontWeight = FontWeight.Bold) Providers(AmbientContentAlpha provides ContentAlpha.medium) { Text(&amp;quot;3 minutes ago&amp;quot;, style = MaterialTheme.typography.body2) } }  横に並べるには Rowを使う
Row { Surface( modifier = Modifier.preferredSize(50.dp), shape = CircleShape, color = MaterialTheme.colors.onSurface.copy(alpha = 0.2f) ) { // image goes here } Column { Text(&amp;quot;Alfred Sisley&amp;quot;, fontWeight = FontWeight.Bold) Providers(AmbientContentAlpha provides ContentAlpha.medium) { Text(&amp;quot;3 minutes ago&amp;quot;, style = MaterialTheme.typography.body2) } } }  ここでは、円形画像のプレースホルダーを作るためにSurfaceを使って、先程のColumnと横に並べています。</description>
    </item>
    
    <item>
      <title>Jetpack ComposeでBitmapを表示するには</title>
      <link>https://kwmt27.net/2021/01/31/jetpack-compose-about-bitmap/</link>
      <pubDate>Sun, 31 Jan 2021 22:50:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/01/31/jetpack-compose-about-bitmap/</guid>
      <description>Jetpack ComposeでBitmapを表示するには、Image関数を使い、引数にBitmapを渡せばいいのですが、そのときImageBitmapに変換する必要があるようで、 そのためにasImageBitmap()という拡張関数が生えてるので、それを使えばよさそうです。
import androidx.compose.foundation.Image import androidx.compose.ui.graphics.asImageBitmap Image( bitmap.asImageBitmap(), )  </description>
    </item>
    
    <item>
      <title>Jetpack Composeでダークテーマ設定変更によるステータスバーカラーの切り替え方</title>
      <link>https://kwmt27.net/2021/01/24/jetpack-compose-about-swtich-status-bar/</link>
      <pubDate>Sun, 24 Jan 2021 22:50:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/01/24/jetpack-compose-about-swtich-status-bar/</guid>
      <description>はじめに Android端末でダークテーマの切り替えをしたとき、Jetpack Composeでステータスバーカラーの切りかえをする方法を調べたので、メモ。
方法 Jetpack Composeのサンプル、Jetsnackのコードを参考にしています。
interface SystemUiController { fun setStatusBarColor( color: Color, darkIcons: Boolean = color.luminance() &amp;gt; 0.5f ) } fun SystemUiController(window: Window): SystemUiController { return SystemUiControllerImpl(window) } /** * An [androidx.compose.runtime.Ambient] holding the current [SysUiController]. Defaults to a * no-op controller; consumers should [provide][androidx.compose.runtime.Providers] a real one. */ val SysUiController = staticAmbientOf&amp;lt;SystemUiController&amp;gt; { FakeSystemUiController } private class SystemUiControllerImpl(private val window: Window) : SystemUiController { override fun setStatusBarColor( color: Color, darkIcons: Boolean ) { window.</description>
    </item>
    
    <item>
      <title>Jetpack ComposeのAmbientについて</title>
      <link>https://kwmt27.net/2021/01/17/jetpack-compose-about-ambient/</link>
      <pubDate>Sun, 17 Jan 2021 22:50:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/01/17/jetpack-compose-about-ambient/</guid>
      <description>はじめに Jetpack Composeでステータスバーのカラーを変更するにはどうすればいいか調べていたら、ambientというキーワードが出てきて、なにものかがわからなかったのでメモです。
Ambientとは Ambientとは、FlutterのProviderのようなものです。
サンプルコードを見たほうがわかりやすいと思いますので、見てみましょう。
// ① Ambientを作ります。 val ActiveUser = ambientOf&amp;lt;User&amp;gt; { error(&amp;quot;No active user found!&amp;quot;) } @Composable fun App(user: User) { // ② `Providers`コンポーネントを使用して、ambinentに値を渡します。 Providers(ActiveUser provides user) { SomeScreen() } } // ③ツリーの間にあるコンポーネントはAmbientの値を知る必要はありません。 @Composable fun SomeScreen() { UserPhoto() } @Composable fun UserPhoto() { // ④ `current`プロパティを使うことでAmbinentの値を使うことができます。 val user = ActiveUser.current ProfileIcon(src = user.profilePhotoUrl) }  もしAmbientを使わなければ、コンポーネントに引数で渡していくことになり、渡された値が必要のないコンポーネントまで余計なものを知る必要が出てきてしまいます。
ambientOfとstaticAmbinentOfの違いについて Jetpack Compose - What is the Difference Between ambientOf and staticAmbientOf こちらが詳しいです。</description>
    </item>
    
    <item>
      <title>Jetpack Composeを既存のアプリと共存するには</title>
      <link>https://kwmt27.net/2021/01/16/jetpack-compose/</link>
      <pubDate>Sat, 16 Jan 2021 22:50:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2021/01/16/jetpack-compose/</guid>
      <description>現象 次のエラーが出た。
Execution failed for task &#39;:core:presentation:prepareDebugKotlinCompileTask&#39;. &amp;gt; Could not resolve all files for configuration &#39;:core:presentation:kotlin-extension&#39;. &amp;gt; Could not find androidx.compose:compose-compiler:1.0.0-alpha08. Searched in the following locations: - https://dl.google.com/dl/android/maven2/androidx/compose/compose-compiler/1.0.0-alpha08/compose-compiler-1.0.0-alpha08.pom - https://jcenter.bintray.com/androidx/compose/compose-compiler/1.0.0-alpha08/compose-compiler-1.0.0-alpha08.pom - https://www.jitpack.io/androidx/compose/compose-compiler/1.0.0-alpha08/compose-compiler-1.0.0-alpha08.pom - https://oss.sonatype.org/content/repositories/snapshots/androidx/compose/compose-compiler/1.0.0-alpha08/compose-compiler-1.0.0-alpha08.pom - https://kotlin.bintray.com/kotlinx/androidx/compose/compose-compiler/1.0.0-alpha08/compose-compiler-1.0.0-alpha08.pom Required by: project :core:presentation Possible solution: - Declare repository providing the artifact, see the documentation at https://docs.gradle.org/current/userguide/declaring_repositories.html  原因 Android Gradle Pluginのバージョンが古かったため
対策  classpath(&amp;quot;com.android.tools.build:gradle:4.1.0&amp;quot;) + classpath(&amp;quot;com.android.tools.build:gradle:7.0.0-alpha02&amp;quot;)  -distributionUrl=https\://services.gradle.org/distributions/gradle-6.7-all.zip +distributionUrl=https://services.gradle.org/distributions/gradle-6.7.1-all.zip  現象 AGPのバージョンを7.0.0にするとGradle Syncで以下のエラーが出る classpath(&amp;ldquo;com.</description>
    </item>
    
    <item>
      <title>Navigation Architecture ComponentでToolbarのバックボタンを非表示にするには</title>
      <link>https://kwmt27.net/2019/10/11/how-to-remove-back-button-of-toolbar-with-navigation-component/</link>
      <pubDate>Fri, 11 Oct 2019 16:40:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2019/10/11/how-to-remove-back-button-of-toolbar-with-navigation-component/</guid>
      <description>こちらを参照 https://stackoverflow.com/a/57169105/2520998
トップレベルのDestinationだったら非表示になるから、非表示にしたいDestinationをトップレベルに設定すればいい、とのこと。
こちらのサンプルを例にした場合、次のようにするとよさそう。
 </description>
    </item>
    
    <item>
      <title>Principles of Navigationの翻訳</title>
      <link>https://kwmt27.net/2018/05/23/android-principles-of-navigation/</link>
      <pubDate>Wed, 23 May 2018 10:00:00 +0900</pubDate>
      
      <guid>https://kwmt27.net/2018/05/23/android-principles-of-navigation/</guid>
      <description> はじめに Principles of Navigation(Navigationの原則)を一度読んでみたほうが良さそうと思って読んでみた時のメモというか翻訳です。
Principles of Navigation(Navigationの原則) アプリ内ナビゲーションの目標は、ユーザーに一貫した予測可能なエクスペリエンスを提供することです。この目標を達成するために、ナビゲーションアーキテクチャコンポーネントは、以下の各ナビゲーション原則に準拠したアプリを構築するのに役立ちます。
アプリは決まった最初の遷移先がある アプリにはユーザーがランチャーからアプリを起動したときに見る決まった遷移先の画面があります。この遷移先は、戻るボタンを押した後、ランチャーに戻るときの最後に表示される画面になるはずです。
注意: アプリに1回限りの設定や一連のログイン画面がある可能性があります。これらの条件付き画面は、アプリの最初の遷移先とみなすべきではありません。
スタックは、アプリの「ナビゲーション状態」を表すために使用 アプリのナビゲーション状態は、LIFO(後入れ先出し構造)で表される必要があります。 この「ナビゲーションスタック」は、スタックの一番下にアプリの最初の遷移先があり、スタックの一番上に現在の遷移先があるはずです。
ナビゲーションスタックを変更する操作は、新しい遷移先をスタックの先頭に「プッシュ」するか、最上部の遷移先をスタックから「ポップ」することによって、常にナビゲーションスタックの一番上で操作する必要があります。
Upボタンはアプリを終了させない ユーザーが最初の遷移先にいる場合は、Upボタンを表示すべきではありません。他のアプリのタスク上でディープリンクを使用してアプリを起動すると、Upボタンは階層的に親の遷移先に戻り、他のアプリに戻るべきではありません。
UpボタンとBackボタンはアプリのタスク内で同等 自分のアプリのタスク上にいて最初の遷移先にいないときのような、システムのバックボタンがアプリを終了しない場合、Upボタンはシステムのバックボタンと同等に機能すべきです。
ディープリンクで遷移する場合や通所の遷移で同じ同じ遷移先への遷移する場合、同じスタック状態となるべき ユーザーは最初の遷移先でアプリに入って、別の遷移先に遷移します。また同じ遷移先に遷移するために、可能ならディープリンクも使います。 両方のケースで、ナビゲーションスタックは遷移先が同じスタック状態になるべきです。 特に、ユーザーは、どのように遷移先に到達したかにかかわらず、バックボタンやUpボタンを使って、最初の遷移先まで戻れるべきです。 既存のナビゲーションスタックは削除され、ディープリンクのナビゲーションスタックに置き換えられます。
翻訳について  Destination  遷移先  ※DestinationはNavigationにおいて、画面の意味があるので、遷移先の画面としてしまおうかと思ったり、Destinationのままにしようかと悩みましたが、遷移先に統一しました。   start destination  最初の遷移先  ※Navigationにおいて、アプリ起動時の画面を意味しています。また開始先のような訳も考えましたが、上記Destinationを遷移先としたので、最初の遷移先としました。   navigation stack  ナビゲーションスタック   </description>
    </item>
    
  </channel>
</rss>